<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Definitive Interactive Intertemporal Choice Model</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0KOVEMVIhbGKZC0svKNUROgsE7FVU2TwuUmdlNP9GGUo2CRI3BlgN" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Source+Serif+4:opsz,wght@8..60,400;8..60,600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* A slightly cooler gray */
        }
        .katex { font-size: 1.05em; }
        .section-title { font-family: 'Source Serif 4', serif; font-weight: 600; }
        .tooltip {
            position: absolute; text-align: center; padding: 8px 12px;
            font: 12px 'Inter', sans-serif; background: rgba(15, 23, 42, 0.9);
            color: white; border: 0px; border-radius: 8px; pointer-events: none;
            opacity: 0; transition: opacity 0.2s; backdrop-filter: blur(4px);
        }
        .shock-btn {
            transition: all 0.2s ease-in-out;
        }
        .shock-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .story-highlight {
            background-color: rgba(239, 246, 255, 1); /* blue-50 */
            border-left: 3px solid rgba(59, 130, 246, 1); /* blue-500 */
            padding: 0.75rem;
            border-radius: 0.25rem;
        }
    </style>
</head>
<body class="antialiased text-slate-800">

    <div class="max-w-screen-2xl mx-auto p-4 sm:p-6 lg:p-8">
        <div class="text-center mb-10">
            <h1 class="text-4xl font-bold text-slate-900 tracking-tight sm:text-5xl section-title">The Intertemporal Choice Dashboard</h1>
            <p class="mt-3 text-lg text-slate-600 max-w-4xl mx-auto">An analytical environment for exploring consumption-saving decisions, comparative statics, and consumption smoothing.</p>
        </div>

        <div class="grid grid-cols-1 xl:grid-cols-12 gap-6">
            
            <!-- Left Column: Controls & Shocks -->
            <div class="xl:col-span-3 space-y-6">
                <div class="bg-white p-6 rounded-2xl shadow-lg border border-slate-200">
                    <h2 class="text-2xl text-slate-800 border-b pb-3 mb-4 section-title">Parameters</h2>
                    <div id="controls-container" class="space-y-5">
                        <!-- Sliders will be injected here -->
                    </div>
                </div>
                <div class="bg-white p-6 rounded-2xl shadow-lg border border-slate-200">
                    <h2 class="text-2xl text-slate-800 border-b pb-3 mb-4 section-title">Comparative Statics</h2>
                    <div id="shocks-container" class="grid grid-cols-2 gap-3 text-sm">
                        <!-- Shock buttons will be injected here -->
                    </div>
                    <div class="flex items-center space-x-3 mt-4">
                         <input type="checkbox" id="decompose-toggle" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                         <label for="decompose-toggle" class="text-slate-700">Decompose Effects</label>
                    </div>
                </div>
            </div>

            <!-- Middle Column: Visualizations -->
            <div class="xl:col-span-6 bg-white p-4 sm:p-6 rounded-2xl shadow-xl border border-slate-200">
                <div id="graph-container"></div>
                <div id="legend-container" class="flex flex-wrap justify-center items-center gap-x-4 gap-y-2 mt-4 text-xs"></div>
                <div class="mt-4 border-t pt-4">
                     <h3 class="text-lg font-semibold text-slate-700 text-center mb-2">Consumption Path</h3>
                     <div id="path-chart-container"></div>
                </div>
            </div>

            <!-- Right Column: Analysis -->
            <div class="xl:col-span-3 bg-white p-6 rounded-2xl shadow-lg border border-slate-200">
                <h2 class="text-2xl text-slate-800 border-b pb-3 mb-4 section-title">Analysis</h2>
                <div id="story-container" class="text-sm text-slate-700 leading-relaxed mb-6"></div>
                <div id="equations-container" class="space-y-4 text-sm">
                    <!-- Equations will be injected here -->
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // --- D3 AND APP LOGIC ---
        const ease = d3.easeCubicOut;
        const DURATION = 500;

        const COLORS = {
            budget: "#1e293b", indifference: "#c2410c", endowment: "#16a34a",
            optimal: "#c2410c", saving: "#2563eb", euler: "#94a3b8", grid: "#e2e8f0",
            hypothetical: "#7c3aed", substitution: "#0891b2", income: "#f59e0b",
            c1: "#1d4ed8", c2: "#047857"
        };

        // --- STATE MANAGEMENT ---
        let state = {};
        let initialState = null;
        let isDecomposing = false;

        // --- PARAMETERS & CONTROLS ---
        const params = {
            y1: { min: 10, max: 200, value: 100, step: 1, label: "Income Today", symbol: "y₁" },
            y2: { min: 10, max: 200, value: 100, step: 1, label: "Income Tomorrow", symbol: "y₂" },
            r: { min: -0.2, max: 0.5, value: 0.05, step: 0.01, label: "Interest Rate", symbol: "r" },
            beta: { min: 0.8, max: 1.2, value: 1.0, step: 0.01, label: "Discount Factor", symbol: "β" },
            sigma: { min: 0.5, max: 5, value: 1.0, step: 0.1, label: "Risk Aversion", symbol: "σ" }
        };

        const shocks = {
            'r_hike': { label: "Rate Hike", param: 'r', change: 0.05 },
            'r_cut': { label: "Rate Cut", param: 'r', change: -0.05 },
            'y1_temp': { label: "Temp. Income +", param: 'y1', change: 20 },
            'y_perm': { label: "Perm. Income +", params: ['y1', 'y2'], change: 20 }
        };

        function initializeControls() {
            const controlsContainer = d3.select("#controls-container");
            Object.entries(params).forEach(([key, p]) => {
                const controlHtml = `
                    <div>
                        <label for="${key}" class="flex justify-between text-sm font-medium text-slate-600">
                            <span>${p.label} ($${p.symbol}$)</span>
                            <span id="${key}-value" class="font-semibold text-slate-800"></span>
                        </label>
                        <input type="range" id="${key}" min="${p.min}" max="${p.max}" value="${p.value}" step="${p.step}" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                    </div>`;
                controlsContainer.html(controlsContainer.html() + controlHtml);
            });

            const shocksContainer = d3.select("#shocks-container");
            Object.entries(shocks).forEach(([key, s]) => {
                const shockBtn = `<button id="${key}" class="shock-btn w-full bg-slate-100 text-slate-700 font-semibold py-2 px-2 rounded-lg shadow-sm hover:bg-slate-200">${s.label}</button>`;
                shocksContainer.html(shocksContainer.html() + shockBtn);
            });
        }

        // --- CORE CALCULATIONS ---
        function calculateState() {
            const currentState = {};
            Object.keys(params).forEach(key => currentState[key] = +d3.select(`#${key}`).property("value"));
            
            const { y1, y2, r, beta, sigma } = currentState;
            currentState.W = y1 + y2 / (1 + r);

            if (Math.abs(sigma - 1.0) < 1e-5) {
                currentState.c1_star = currentState.W / (1 + beta);
            } else {
                const K = Math.pow(beta * (1 + r), 1 / sigma);
                currentState.c1_star = currentState.W / (1 + K / (1 + r));
            }
            currentState.c2_star = Math.pow(beta * (1 + r), 1 / sigma) * currentState.c1_star;
            currentState.saving = y1 - currentState.c1_star;
            
            if (Math.abs(sigma - 1.0) < 1e-5) {
                currentState.U_star = Math.log(currentState.c1_star) + beta * Math.log(currentState.c2_star);
            } else {
                currentState.U_star = (Math.pow(currentState.c1_star, 1 - sigma) - 1) / (1 - sigma) + beta * ((Math.pow(currentState.c2_star, 1 - sigma) - 1) / (1 - sigma));
            }
            return currentState;
        }

        function calculateDecomposition(initial, current) {
            const { U_star: U0 } = initial;
            const { r: r1, beta, sigma } = current;
            let c1_h, c2_h;
            if (Math.abs(sigma - 1.0) < 1e-5) { // Log
                const term = Math.exp(U0) * Math.pow(beta * (1 + r1), -beta);
                c1_h = Math.pow(term, 1 / (1 + beta));
            } else { // CRRA
                const K_h = Math.pow(beta * (1 + r1), 1 / sigma);
                const U_term = (U0 * (1 - sigma) + 1 + beta) / (1 + beta * Math.pow(K_h, 1 - sigma));
                c1_h = (U_term < 0) ? 0 : Math.pow(U_term, 1 / (1 - sigma));
            }
            c2_h = Math.pow(beta * (1 + r1), 1 / sigma) * c1_h;
            return { c1_h, c2_h, initial };
        }

        // --- D3 VISUALIZATION SETUP ---
        const mainMargin = { top: 20, right: 20, bottom: 50, left: 60 };
        const mainContainer = document.getElementById('graph-container');
        let mainWidth = mainContainer.clientWidth - mainMargin.left - mainMargin.right;
        let mainHeight = mainWidth * 0.8;

        const mainSvg = d3.select("#graph-container").append("svg")
            .attr("viewBox", `0 0 ${mainWidth + mainMargin.left + mainMargin.right} ${mainHeight + mainMargin.top + mainMargin.bottom}`)
            .append("g").attr("transform", `translate(${mainMargin.left},${mainMargin.top})`);
        
        const pathMargin = { top: 10, right: 20, bottom: 30, left: 60 };
        const pathContainer = document.getElementById('path-chart-container');
        let pathWidth = pathContainer.clientWidth - pathMargin.left - pathMargin.right;
        let pathHeight = 100;

        const pathSvg = d3.select("#path-chart-container").append("svg")
             .attr("viewBox", `0 0 ${pathWidth + pathMargin.left + pathMargin.right} ${pathHeight + pathMargin.top + pathMargin.bottom}`)
             .append("g").attr("transform", `translate(${pathMargin.left},${pathMargin.top})`);
        
        // Main chart elements
        const mainXScale = d3.scaleLinear().range([0, mainWidth]);
        const mainYScale = d3.scaleLinear().range([mainHeight, 0]);
        const mainElements = {
            grid: mainSvg.append("g"),
            effectGroup: mainSvg.append("g").style("opacity", 0),
            budgetLine: mainSvg.append("path").attr("fill", "none").attr("stroke", COLORS.budget).attr("stroke-width", 2.5),
            indifferenceCurve: mainSvg.append("path").attr("fill", "none").attr("stroke", COLORS.indifference).attr("stroke-width", 2).attr("stroke-dasharray", "6 4"),
            savingVector: mainSvg.append("line").attr("stroke", COLORS.saving).attr("stroke-width", 2).attr("marker-end", "url(#arrow-saving)"),
            endowmentPoint: mainSvg.append("circle").attr("r", 7).attr("fill", COLORS.endowment).attr("stroke", "#ffffff").attr("stroke-width", 2),
            optimalPoint: mainSvg.append("circle").attr("r", 7).attr("fill", COLORS.optimal).attr("stroke", "#ffffff").attr("stroke-width", 2).style("filter", "url(#glow)"),
        };
        mainElements.initialBudgetLine = mainElements.effectGroup.append("path").attr("fill", "none").attr("stroke", COLORS.budget).attr("stroke-width", 1.5).attr("stroke-opacity", 0.4);
        mainElements.hypotheticalBudgetLine = mainElements.effectGroup.append("path").attr("fill", "none").attr("stroke", COLORS.hypothetical).attr("stroke-width", 2).attr("stroke-dasharray", "5 5");
        mainElements.substitutionVector = mainElements.effectGroup.append("line").attr("stroke", COLORS.substitution).attr("stroke-width", 2.5).attr("marker-end", "url(#arrow-sub)");
        mainElements.incomeVector = mainElements.effectGroup.append("line").attr("stroke", COLORS.income).attr("stroke-width", 2.5).attr("marker-end", "url(#arrow-inc)");
        mainElements.initialOptimalPoint = mainElements.effectGroup.append("circle").attr("r", 7).attr("fill", COLORS.optimal).attr("stroke", "#ffffff").attr("stroke-width", 2).attr("fill-opacity", 0.5);
        mainElements.hypotheticalPoint = mainElements.effectGroup.append("circle").attr("r", 7).attr("fill", COLORS.hypothetical).attr("stroke", "#ffffff").attr("stroke-width", 2);
        
        // Path chart elements
        const pathXScale = d3.scaleBand().range([0, pathWidth]).padding(0.4);
        const pathYScale = d3.scaleLinear().range([pathHeight, 0]);
        const pathElements = {
            xAxis: pathSvg.append("g").attr("transform", `translate(0,${pathHeight})`),
            yAxis: pathSvg.append("g"),
            bars: pathSvg.selectAll(".bar").data([{period: "c₁"}, {period: "c₂"}]).enter()
        };
        pathElements.c1Bar = pathElements.bars.append("rect").attr("class", "bar c1-bar").attr("fill", COLORS.c1);
        pathElements.c2Bar = pathElements.bars.append("rect").attr("class", "bar c2-bar").attr("fill", COLORS.c2);

        // --- RENDER FUNCTIONS ---
        function render() {
            state = calculateState();
            
            // Render UI components
            Object.entries(params).forEach(([key, p]) => {
                const val = state[key];
                const format = (p.symbol === 'r') ? `${(val * 100).toFixed(1)}%` : val.toFixed(p.step < 1 ? 2 : 0);
                d3.select(`#${key}-value`).text(format);
            });
            
            // Render visualizations and text
            renderMainChart();
            renderPathChart();
            renderAnalysis();
            renderLegend();
        }

        function renderMainChart() {
            const t = d3.transition().duration(DURATION).ease(ease);
            let decompState = null;
            if (isDecomposing && initialState) {
                decompState = calculateDecomposition(initialState, state);
            }

            const all_c1 = [state.W, state.y1, state.c1_star, decompState?.c1_h, initialState?.c1_star].filter(d => d);
            const all_c2 = [state.W * (1 + state.r), state.y2, state.c2_star, decompState?.c2_h, initialState?.c2_star].filter(d => d);
            const max_val = d3.max([...all_c1, ...all_c2]) * 1.15;
            
            mainXScale.domain([0, max_val]);
            mainYScale.domain([0, max_val]);

            mainSvg.select(".x-axis").transition(t).call(d3.axisBottom(mainXScale));
            mainSvg.select(".y-axis").transition(t).call(d3.axisLeft(mainYScale));
            
            const lineGen = d3.line().x(d => mainXScale(d.x)).y(d => mainYScale(d.y));
            mainElements.budgetLine.datum([{x: 0, y: state.W * (1 + state.r)}, {x: state.W, y: 0}]).transition(t).attr("d", lineGen);
            
            // Generate and draw indifference curve
            const icPoints = [];
            for (let i = 1; i < 150; i++) {
                const c1 = (max_val / 150) * i;
                let c2;
                if (Math.abs(state.sigma - 1.0) < 1e-5) { c2 = Math.exp((state.U_star - Math.log(c1)) / state.beta); } 
                else {
                    const term1 = (1 - state.sigma) / state.beta;
                    const term2 = state.U_star - ((Math.pow(c1, 1 - state.sigma) - 1) / (1 - state.sigma));
                    const c2_term = 1 + term1 * term2;
                    if (c2_term < 0) continue;
                    c2 = Math.pow(c2_term, 1 / (1 - state.sigma));
                }
                if (c1 > 0 && c2 > 0 && c2 < max_val * 1.5) { icPoints.push({ x: c1, y: c2 }); }
            }
            mainElements.indifferenceCurve.datum(icPoints).transition(t).attr("d", lineGen);
            
            mainElements.savingVector.transition(t).attr("x1", mainXScale(state.y1)).attr("y1", mainYScale(state.y2)).attr("x2", mainXScale(state.c1_star)).attr("y2", mainYScale(state.c2_star));
            mainElements.endowmentPoint.transition(t).attr("cx", mainXScale(state.y1)).attr("cy", mainYScale(state.y2));
            mainElements.optimalPoint.transition(t).attr("cx", mainXScale(state.c1_star)).attr("cy", mainYScale(state.c2_star));

            if (decompState) {
                mainElements.initialBudgetLine.datum([{x: 0, y: decompState.initial.W * (1 + decompState.initial.r)}, {x: decompState.initial.W, y: 0}]).transition(t).attr("d", lineGen);
                mainElements.hypotheticalBudgetLine.datum([{x: 0, y: (decompState.c1_h + decompState.c2_h / (1 + state.r)) * (1 + state.r)}, {x: decompState.c1_h + decompState.c2_h / (1 + state.r), y: 0}]).transition(t).attr("d", lineGen);
                mainElements.initialOptimalPoint.transition(t).attr("cx", mainXScale(decompState.initial.c1_star)).attr("cy", mainYScale(decompState.initial.c2_star));
                mainElements.hypotheticalPoint.transition(t).attr("cx", mainXScale(decompState.c1_h)).attr("cy", mainYScale(decompState.c2_h));
                mainElements.substitutionVector.transition(t).attr("x1", mainXScale(decompState.initial.c1_star)).attr("y1", mainYScale(decompState.initial.c2_star)).attr("x2", mainXScale(decompState.c1_h)).attr("y2", mainYScale(decompState.c2_h));
                mainElements.incomeVector.transition(t).attr("x1", mainXScale(decompState.c1_h)).attr("y1", mainYScale(decompState.c2_h)).attr("x2", mainXScale(state.c1_star)).attr("y2", mainYScale(state.c2_star));
            }
        }

        function renderPathChart() {
            const t = d3.transition().duration(DURATION).ease(ease);
            const data = [{period: "c₁", value: state.c1_star}, {period: "c₂", value: state.c2_star}];
            const max_val = d3.max(data, d => d.value) * 1.2;

            pathXScale.domain(data.map(d => d.period));
            pathYScale.domain([0, max_val]);
            
            pathElements.xAxis.transition(t).call(d3.axisBottom(pathXScale).tickSize(0)).select(".domain").remove();
            pathElements.yAxis.transition(t).call(d3.axisLeft(pathYScale).ticks(3));

            pathSvg.selectAll(".bar").data(data)
                .transition(t)
                .attr("x", d => pathXScale(d.period))
                .attr("y", d => pathYScale(d.value))
                .attr("width", pathXScale.bandwidth())
                .attr("height", d => pathHeight - pathYScale(d.value));
        }

        function renderAnalysis() {
            // Equations
            const utility_latex = Math.abs(state.sigma - 1.0) < 1e-5 ? `U = \\ln(c_1) + \\beta \\ln(c_2)` : `U = \\frac{c_1^{1-\\sigma}-1}{1-\\sigma} + \\beta \\frac{c_2^{1-\\sigma}-1}{1-\\sigma}`;
            const wealth_latex = `W = y_1 + \\frac{y_2}{1+r} = ${state.y1.toFixed(0)} + \\frac{${state.y2.toFixed(0)}}{1+${state.r.toFixed(2)}} = \\$${state.W.toFixed(2)}`;
            const euler_latex = `(\\frac{c_2^*}{c_1^*})^{\\sigma} = \\beta(1+r)`;
            
            const equationsContainer = d3.select("#equations-container");
            equationsContainer.html(`
                <div class="p-3 bg-slate-50 rounded-md"><div id="utility-eq"></div></div>
                <div class="p-3 bg-slate-50 rounded-md"><div id="wealth-eq"></div></div>
                <div class="p-3 bg-slate-50 rounded-md"><div id="euler-eq"></div></div>
            `);
            katex.render(utility_latex, document.getElementById('utility-eq'), { throwOnError: false });
            katex.render(wealth_latex, document.getElementById('wealth-eq'), { throwOnError: false });
            katex.render(euler_latex, document.getElementById('euler-eq'), { throwOnError: false });

            // Story
            let story = "";
            if (isDecomposing && initialState) {
                const decompState = calculateDecomposition(initialState, state);
                const sub_effect = decompState.c1_h - initialState.c1_star;
                const inc_effect = state.c1_star - decompState.c1_h;
                const r_change = state.r > initialState.r;
                const was_saver = initialState.saving > 0;
                
                story += `A change in the interest rate from <b>${(initialState.r*100).toFixed(1)}%</b> to <b>${(state.r*100).toFixed(1)}%</b> alters the consumer's choice.<br><br>`;
                story += `<div class="story-highlight">The <b>Substitution Effect</b> makes future consumption relatively ${r_change ? 'cheaper' : 'pricier'}, causing the consumer to substitute ${sub_effect > 0 ? 'towards' : 'away from'} current consumption by <b>${sub_effect.toFixed(2)}</b>.</div><br>`;
                story += `<div class="story-highlight">The <b>Income Effect</b> makes the consumer feel ${ (r_change && was_saver) || (!r_change && !was_saver) ? 'wealthier' : 'poorer' }, changing current consumption by <b>${inc_effect.toFixed(2)}</b>.</div>`;
            } else {
                const saver_status = state.saving > 1 ? "a net saver" : state.saving < -1 ? "a net borrower" : "consuming their income in each period";
                story = `The consumer is currently <b>${saver_status}</b>, with savings of <b>$${state.saving.toFixed(2)}</b>. `;
                const smoothing_ratio = Math.min(state.c1_star, state.c2_star) / Math.max(state.c1_star, state.c2_star);
                if (smoothing_ratio > 0.9) story += "They are achieving a high degree of consumption smoothing.";
                else if (smoothing_ratio < 0.6) story += "Their consumption path is relatively volatile.";
            }
            d3.select("#story-container").html(story);
        }
        
        function renderLegend() { /* ... similar to previous version ... */ }
        
        // --- INITIALIZATION ---
        function init() {
            initializeControls();
            
            // Setup axes and defs once
            mainSvg.append("g").attr("class", "x-axis").attr("transform", `translate(0,${mainHeight})`);
            mainSvg.append("g").attr("class", "y-axis");
            mainSvg.append("text").attr("class", "axis-label").attr("text-anchor", "middle").attr("x", mainWidth / 2).attr("y", mainHeight + mainMargin.bottom - 10).html("Consumption Today (c&#x2081;)");
            mainSvg.append("text").attr("class", "axis-label").attr("text-anchor", "middle").attr("transform", "rotate(-90)").attr("x", -mainHeight / 2).attr("y", -mainMargin.left + 20).html("Consumption Tomorrow (c&#x2082;)");
            
            const defs = mainSvg.append("defs");
            const arrowProps = [ { id: "arrow-saving", color: COLORS.saving }, { id: "arrow-sub", color: COLORS.substitution }, { id: "arrow-inc", color: COLORS.income }];
            arrowProps.forEach(d => defs.append("marker").attr("id", d.id).attr("viewBox", "0 -5 10 10").attr("refX", 5).attr("refY", 0).attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", "auto").append("path").attr("d", "M0,-5L10,0L0,5").attr("fill", d.color));
            const filter = defs.append("filter").attr("id", "glow");
            filter.append("feGaussianBlur").attr("stdDeviation", "3.5").attr("result", "coloredBlur");
            const feMerge = filter.append("feMerge");
            feMerge.append("feMergeNode").attr("in", "coloredBlur");
            feMerge.append("feMergeNode").attr("in", "SourceGraphic");

            // Event Listeners
            Object.keys(params).forEach(key => d3.select(`#${key}`).on("input", render));
            d3.select("#decompose-toggle").on("change", function() {
                isDecomposing = this.checked;
                mainElements.effectGroup.style("opacity", isDecomposing ? 1 : 0);
                if (isDecomposing) { initialState = calculateState(); } 
                else { initialState = null; }
                render();
            });
            Object.entries(shocks).forEach(([key, s]) => {
                d3.select(`#${key}`).on("click", () => {
                    initialState = calculateState();
                    if(s.params) {
                        s.params.forEach(p => d3.select(`#${p}`).property("value", state[p] + s.change));
                    } else {
                        d3.select(`#${s.param}`).property("value", state[s.param] + s.change);
                    }
                    isDecomposing = true;
                    d3.select("#decompose-toggle").property("checked", true);
                    mainElements.effectGroup.style("opacity", 1);
                    render();
                });
            });
            
            render(); // Initial render
        }

        init();
    </script>
</body>
</html>
